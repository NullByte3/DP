# Design Patterns: A Compact Summary (Generated by Gemini 2.5 Pro)

This document provides a condensed overview of the Gang of Four (GoF) design patterns, categorized into Creational, Structural, and Behavioral types.

## Table of Contents
1.  [Introduction to Design Patterns](#introduction-to-design-patterns)
2.  [Creational Patterns](#creational-patterns)
    *   [Singleton](#singleton)
    *   [Factory Method](#factory-method)
    *   [Abstract Factory](#abstract-factory)
    *   [Builder](#builder)
    *   [Prototype](#prototype)
3.  [Structural Patterns](#structural-patterns)
    *   [Adapter](#adapter)
    *   [Bridge](#bridge)
    *   [Composite](#composite)
    *   [Decorator](#decorator)
    *   [Facade](#facade)
    *   [Flyweight](#flyweight)
    *   [Proxy](#proxy)
4.  [Behavioral Patterns](#behavioral-patterns)
    *   [Chain of Responsibility](#chain-of-responsibility)
    *   [Command](#command)
    *   [Iterator](#iterator)
    *   [Mediator](#mediator)
    *   [Memento](#memento)
    *   [Observer](#observer)
    *   [State](#state)
    *   [Strategy](#strategy)
    *   [Template Method](#template-method)
    *   [Visitor](#visitor)
5.  [Glossary of Terms](#glossary-of-terms)

---

## Introduction to Design Patterns

*   **Concept**: Reusable, high-level solutions to commonly occurring problems in object-oriented programming. They are language-independent "tools of thinking" that represent shared knowledge among developers.
*   **Core Objectives**:
    *   **Loose Coupling**: Minimize dependencies between components. "Each part of the code knows as few other parts as possible."
    *   **High Cohesion**: Group similar parts together while separating different parts. "Each part of the code does just one thing."
*   **GoF (Gang of Four)**: The 23 established patterns from the book *Design Patterns: Elements of Reusable Object-Oriented Software*. They are categorized as Creational, Structural, and Behavioral.
*   **Architectural vs. Design Patterns**:
    *   **Architectural Patterns** (e.g., MVC) describe the high-level structure of an application (like layers).
    *   **Design Patterns** focus on solving recurring technical design problems and challenges.

---

## Creational Patterns

Patterns that abstract the object-instantiation process.

### Singleton
*   **Idea**: Guarantees a class has only one instance and provides a global point of access to it.
*   **Structure**:
    *   A `private static` field to hold the single instance.
    *   A `private` constructor to prevent direct instantiation.
    *   A `public static getInstance()` method that creates the instance if it doesn't exist and returns it.
*   **Use Cases**: Resource management (e.g., a single database connection), globally accessible objects, consistency (e.g., one clock).
*   **Drawbacks**: Introduces global state, promotes tight coupling, and complicates unit testing.
*   **Variations**:
    *   **Thread-Safe**: Use the `synchronized` keyword or double-checked locking.
    *   **Eager Instantiation**: Create the instance when the class is loaded.
    *   **Enum Trick**: A Java Enum provides an elegant, thread-safe singleton implementation.

### Factory Method
*   **Idea**: Defines an interface for creating an object but lets subclasses decide which class to instantiate. It defers instantiation to subclasses.
*   **Structure**:
    *   **Product**: An interface for the objects the factory method creates.
    *   **ConcreteProduct**: Implements the `Product` interface.
    *   **Creator (Abstract)**: Declares the `factoryMethod()`, which returns a `Product` object.
    *   **ConcreteCreator**: Overrides the `factoryMethod()` to return an instance of a `ConcreteProduct`.
*   **Use Cases**: Used heavily in frameworks (e.g., JavaFX `Application`) where client code needs to create objects but only the framework knows when. Connects parallel class hierarchies.

### Abstract Factory
*   **Idea**: Provides an interface for creating *families of related or dependent objects* without specifying their concrete classes.
*   **Structure**:
    *   **AbstractFactory**: An interface with methods for creating each abstract product (e.g., `createWindow()`, `createScrollBar()`).
    *   **ConcreteFactory**: Implements the `AbstractFactory` to create a specific family of concrete products (e.g., `MotifWidgetFactory`).
    *   **AbstractProduct**: An interface for a type of product (e.g., `Window`).
    *   **ConcreteProduct**: Implements an `AbstractProduct` for a specific family (e.g., `MotifWindow`).
*   **Use Cases**: Creating UI components for different themes, ensuring that all created products from a family are compatible.
*   **Drawbacks**: Can lead to a large number of classes. Adding a new product type requires modifying all factory interfaces, potentially violating the Open/Closed Principle.

### Builder
*   **Idea**: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
*   **Structure**:
    *   **Builder**: An interface specifying methods for building parts of the product.
    *   **ConcreteBuilder**: Implements the `Builder` interface, constructs parts, and provides a method to retrieve the final product.
    *   **Product**: The complex object being built.
    *   **Director**: Orchestrates the construction process using a `Builder` instance.
*   **Use Cases**: Creating complex objects step-by-step, avoiding "telescoping constructors." A prime example is Java's `StringBuilder`.

### Prototype
*   **Idea**: Creates new objects by copying an existing instance (a "prototype"), which is often more efficient than creating an object from scratch.
*   **Structure**:
    *   **Prototype**: An interface that declares a `clone()` method.
    *   **ConcretePrototype**: Implements the `clone()` method to create a copy of itself.
    *   **Client**: Asks a prototype to clone itself to get a new object.
*   **Use Cases**: When object creation is expensive; when a system needs to be independent of how its objects are created.
*   **Note**: Requires careful handling of **deep vs. shallow copying**. Java's `Cloneable` interface is related to this pattern.

---

## Structural Patterns

Patterns that explain how to assemble objects and classes into larger structures.

### Adapter
*   **Idea**: Allows objects with incompatible interfaces to work together by acting as a wrapper or translator.
*   **Structure**:
    *   **Target**: The domain-specific interface the client uses.
    *   **Adaptee**: The existing class with an incompatible interface that needs adapting.
    *   **Adapter**: A class that implements the `Target` interface and holds a reference to an `Adaptee`. It translates calls from the client into calls on the `Adaptee`.
*   **Use Cases**: Integrating legacy code or third-party libraries. Database JDBC drivers are a classic example.

### Bridge
*   **Idea**: Decouples an abstraction from its implementation so that the two can vary independently.
*   **Structure**: Creates two independent class hierarchies: one for abstractions and one for implementations. The abstraction holds a reference to an implementor object.
    *   **Abstraction**: Defines the high-level interface and maintains a reference to an `Implementor`.
    *   **Implementor**: Defines the interface for implementation classes.
*   **Use Cases**: When an abstraction and its implementation should evolve independently, such as supporting multiple windowing systems in a GUI framework.

### Composite
*   **Idea**: Composes objects into tree-like structures to represent part-whole hierarchies. It lets clients treat individual objects (`Leaf`) and compositions of objects (`Composite`) uniformly.
*   **Structure**:
    *   **Component**: A shared interface for all objects in the composition.
    *   **Leaf**: Represents an individual, terminal object.
    *   **Composite**: Represents a node that can contain other `Component` objects (leaves or other composites).
*   **Use Cases**: Representing hierarchical structures like GUI layouts (e.g., JavaFX `VBox`, `HBox`), file systems, or organizational charts.

### Decorator
*   **Idea**: Attaches additional responsibilities to an object dynamically by wrapping it. Decorators provide a flexible alternative to subclassing for extending functionality.
*   **Structure**:
    *   **Component**: The common interface for both the objects being decorated and the decorators.
    *   **ConcreteComponent**: The base object to which functionality is added.
    *   **Decorator**: An abstract class that implements the `Component` interface and holds a reference to a `Component` object.
    *   **ConcreteDecorator**: Adds specific functionality before or after forwarding the request to the wrapped component.
*   **Use Cases**: Adding features like borders or scrollbars to a UI component without creating a subclass for every possible combination.

### Facade
*   **Idea**: Provides a single, simplified interface to a complex subsystem of classes, making it easier to use.
*   **Structure**: A single `Facade` class delegates client requests to the appropriate objects within the subsystem. The subsystem classes are unaware of the facade.
*   **Use Cases**: Providing a simple API for a complex library (e.g., a compiler), reducing dependencies between a client and a complex system.

### Flyweight
*   **Idea**: Optimizes memory usage by sharing common parts of an object's state among multiple objects, especially when dealing with a large number of fine-grained objects.
*   **Concept**: Divides an object's state into:
    *   **Intrinsic State**: Shared, immutable data stored in the flyweight object.
    *   **Extrinsic State**: Context-dependent, external data passed to the flyweight's methods by the client.
*   **Structure**: A `FlyweightFactory` manages a pool of shared flyweight objects, ensuring only one instance exists for each intrinsic state.
*   **Use Cases**: Characters in a text editor, tiles in a game, or any scenario with a massive number of objects with shared state.

### Proxy
*   **Idea**: Provides a surrogate or placeholder for another object to control access to it.
*   **Structure**: The `Proxy` object implements the same interface as the `RealSubject`, allowing the client to use it interchangeably. The proxy can manage the lifecycle and access to the `RealSubject`.
*   **Types**:
    *   **Virtual Proxy**: Delays object creation until needed (lazy loading).
    *   **Protection Proxy**: Controls access based on permissions.
    *   **Remote Proxy**: A local representative for an object in a different system.
*   **Use Cases**: Lazy loading in JPA/Hibernate, access control, logging, or caching.

---

## Behavioral Patterns

Patterns that identify common communication patterns between objects and realize these patterns.

### Chain of Responsibility
*   **Idea**: Creates a chain of handler objects for a request. Each handler in the chain decides either to process the request or to pass it along to the next handler.
*   **Structure**:
    *   **Handler**: An interface with a method to handle requests and a reference to the next handler (`successor`).
    *   **ConcreteHandler**: Implements the handling logic. If it cannot handle the request, it passes it to its successor.
*   **Use Cases**: GUI event bubbling, processing pipelines where the specific handler is not known beforehand.

### Command
*   **Idea**: Encapsulates a request as an object, allowing for parameterization of clients with different requests, queuing of requests, and support for undoable operations.
*   **Structure**:
    *   **Command**: An interface with a single `execute()` method.
    *   **ConcreteCommand**: Implements the `Command` interface, binding a `Receiver` with an action.
    *   **Receiver**: The object that performs the actual work.
    *   **Invoker**: Asks the command to execute.
*   **Use Cases**: Implementing undo/redo, queuing tasks, GUI actions. JavaFX's `Platform.runLater()` uses this pattern.

### Iterator
*   **Idea**: Provides a standard way to traverse the elements of a collection sequentially without exposing its underlying representation.
*   **Structure**:
    *   **Iterator**: An interface with methods like `hasNext()` and `next()`.
    *   **Aggregate (Iterable)**: An interface with a method to create an `Iterator`.
*   **Use Cases**: Universally used to loop over collections in programming languages (e.g., Java's `java.util.Iterator`).

### Mediator
*   **Idea**: Defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other directly.
*   **Structure**:
    *   **Mediator**: An interface for communication between `Colleague` objects.
    *   **Colleague**: An interface for objects that need to communicate via the mediator.
*   **Use Cases**: Complex GUI dialogs where widgets depend on each other (e.g., enabling a button only when a text field is not empty).

### Memento
*   **Idea**: Captures and externalizes an object's internal state without violating encapsulation, so the object can be restored to this state later.
*   **Structure**:
    *   **Originator**: The object whose state is saved. It creates and uses `Memento` objects.
    *   **Memento**: Stores the internal state of the `Originator`.
    *   **Caretaker**: Manages the history of mementos but does not access their content.
*   **Use Cases**: Implementing undo/redo functionality, saving game states.

### Observer
*   **Idea**: Defines a one-to-many dependency where an object (`Subject`) notifies multiple `Observer` objects automatically of any state changes.
*   **Structure**:
    *   **Subject**: Maintains a list of observers and provides methods to attach (`register`) and detach them.
    *   **Observer**: An interface with an `update()` method.
*   **Use Cases**: Event handling systems, MVC architecture (View observes the Model), subscribing to newsletters.

### State
*   **Idea**: Allows an object to alter its behavior when its internal state changes. The object appears to change its class.
*   **Structure**:
    *   **Context**: The class that has a state. It maintains a reference to a `State` object.
    *   **State**: An interface that encapsulates a behavior associated with a particular state.
    *   **ConcreteState**: Implements a behavior for a specific state and can be responsible for state transitions.
*   **Use Cases**: Implementing finite-state machines (FSMs), managing network connection states, or player character states in a game.

### Strategy
*   **Idea**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from the clients that use it.
*   **Structure**:
    *   **Strategy**: An interface common to all supported algorithms.
    *   **ConcreteStrategy**: Implements a specific algorithm.
    *   **Context**: Is configured with a `ConcreteStrategy` and delegates work to it.
*   **Use Cases**: When multiple algorithms for a task are available, such as different sorting methods, payment strategies, or localization algorithms.

### Template Method
*   **Idea**: Defines the skeleton of an algorithm in a superclass but lets subclasses override specific steps without changing the algorithm's overall structure.
*   **Structure**: An abstract base class defines a `final templateMethod()` that calls a series of abstract or primitive methods. Subclasses must implement the abstract steps.
*   **Use Cases**: Framework development, removing duplicate code by factoring out common behavior into a superclass.

### Visitor
*   **Idea**: Represents an operation to be performed on the elements of an object structure. It allows defining a new operation without changing the classes of the elements on which it operates.
*   **Structure**:
    *   **Visitor**: An interface with a `visit()` method for each type of `ConcreteElement`.
    *   **Element**: An interface with an `accept(Visitor)` method.
*   **Use Cases**: Performing diverse operations on a complex object structure (like a Composite tree). Adding new operations is easy, but adding new element types is difficult.

---

## Glossary of Terms

*   **Abstraction**: The concept of hiding complex implementation details behind a simple interface.
*   **Algorithm**: A specific implementation or procedure for accomplishing a task (e.g., BubbleSort, QuickSort).
*   **API (Application Programming Interface)**: A set of definitions and protocols for building and integrating application software.
*   **Architectural Pattern**: A general, reusable solution to a commonly occurring problem within a given context in software architecture (e.g., MVC).
*   **Chain of Responsibility**: A behavioral design pattern consisting of a source of command objects and a series of processing objects.
*   **Client**: An object or component that uses the functionality provided by another object or system.
*   **Cohesion**: The degree to which the elements inside a module belong together. High cohesion is desirable.
*   **Component**: A modular part of a system. In the Composite pattern, it's the base interface for all objects in the composition.
*   **Coupling**: The degree of interdependence between software modules. Loose coupling is desirable.
*   **Creational Pattern**: A design pattern that deals with object creation mechanisms.
*   **Deep Copy**: A copy process where all objects in the object graph are duplicated, not just the references.
*   **Dependency**: A state in which one object uses the functionality of another object.
*   **Design Pattern**: A general, reusable solution to a commonly occurring problem within a given context in software design.
*   **Director**: A class in the Builder pattern that controls the construction process.
*   **Encapsulation**: The bundling of data with the methods that operate on that data, and the restriction of direct access to some of an object's components.
*   **Extrinsic State**: In the Flyweight pattern, the context-dependent state that is not shared and is passed by the client.
*   **Factory**: An object for creating other objects.
*   **Finite State Machine (FSM)**: A mathematical model of computation that can be in exactly one of a finite number of states at any given time.
*   **Framework**: An abstraction in which software providing generic functionality can be selectively changed by additional user-written code.
*   **GoF (Gang of Four)**: The authors of the seminal book *Design Patterns: Elements of Reusable Object-Oriented Software*.
*   **Handler**: An object in the Chain of Responsibility pattern that processes requests.
*   **Hook**: In the Template Method pattern, a primitive operation with a default (often empty) implementation in the superclass, which subclasses can override.
*   **Inheritance**: A mechanism where a new class derives properties and behavior from an existing class.
*   **Instance**: A concrete occurrence of any object.
*   **Interface**: A shared boundary across which two or more separate components of a computer system exchange information.
*   **Intrinsic State**: In the Flyweight pattern, the immutable state that is shared among multiple objects.
*   **Inversion of Control (IoC)**: A design principle in which custom-written portions of a computer program receive the flow of control from a generic framework. Also known as the "Hollywood Principle" ("Don't call us, we'll call you!").
*   **Invoker**: An object in the Command pattern that triggers a command.
*   **Lazy Loading**: A design pattern that defers initialization of an object until the point at which it is needed.
*   **Leaf**: A node in a tree structure that has no children. In the Composite pattern, it's a terminal object.
*   **Memento**: An object that stores a snapshot of another object's state.
*   **MVC (Model-View-Controller)**: An architectural pattern that separates an application into three main logical components: the model, the view, and the controller.
*   **Object-Oriented Programming (OOP)**: A programming paradigm based on the concept of "objects".
*   **Observer**: An object that wishes to be notified when another object's state changes.
*   **Open/Closed Principle**: A SOLID principle stating that software entities should be open for extension but closed for modification.
*   **Originator**: In the Memento pattern, the object whose state is being saved.
*   **Product**: The object created by a factory or builder.
*   **Prototype**: An initial instance of an object that can be cloned to create new objects.
*   **Proxy**: A surrogate or placeholder object that controls access to another object.
*   **Receiver**: In the Command pattern, the object that performs the actual work when a command is executed.
*   **Shallow Copy**: A copy process where only the references to child objects are copied, not the objects themselves.
*   **SOLID**: An acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.
*   **State**: A particular condition that something is in at a specific time. In the State pattern, an object representing a specific behavior.
*   **Strategy**: An object representing an algorithm.
*   **Subject**: An object that maintains a list of dependents (observers) and notifies them of state changes.
*   **Subsystem**: A self-contained system within a larger system.
*   **Successor**: The next object in a chain or sequence.
*   **Template Method**: A method in a superclass that defines the skeleton of an operation in terms of a number of high-level steps.
*   **Thread Safety**: A computer programming concept applicable to multi-threaded code, ensuring that shared data is accessed safely by multiple threads.
*   **Visitor**: An object that performs an operation on an object structure without modifying the structure itself.